# 프레임워크 없이 SPA 만들기

## 과제 체크포인트

### 기본과제

#### 1) 라우팅 구현:
- [x] History API를 사용하여 SPA 라우터 구현
  - [x] '/' (홈 페이지)
  - [x] '/login' (로그인 페이지)
  - [x] '/profile' (프로필 페이지)
- [x] 각 라우트에 해당하는 컴포넌트 렌더링 함수 작성
- [x] 네비게이션 이벤트 처리 (링크 클릭 시 페이지 전환)
- [x] 주소가 변경되어도 새로고침이 발생하지 않아야 한다.

#### 2) 사용자 관리 기능:
- [x] LocalStorage를 사용한 간단한 사용자 데이터 관리
  - [x] 사용자 정보 저장 (이름, 간단한 소개)
  - [x] 로그인 상태 관리 (로그인/로그아웃 토글)
- [x] 로그인 폼 구현
  - [x] 사용자 이름 입력 및 검증
  - [x] 로그인 버튼 클릭 시 LocalStorage에 사용자 정보 저장
- [x] 로그아웃 기능 구현
  - [x] 로그아웃 버튼 클릭 시 LocalStorage에서 사용자 정보 제거

#### 3) 프로필 페이지 구현:
- [x] 현재 로그인한 사용자의 정보 표시
  - [x] 사용자 이름
  - [x] 간단한 소개
- [x] 프로필 수정 기능
  - [x] 사용자 소개 텍스트 수정 가능
  - [x] 수정된 정보 LocalStorage에 저장

#### 4) 컴포넌트 기반 구조 설계:
- [x] 재사용 가능한 컴포넌트 작성
  - [x] Header 컴포넌트
  - [x] Footer 컴포넌트
- [x] 페이지별 컴포넌트 작성
  - [x] HomePage 컴포넌트
  - [x] ProfilePage 컴포넌트
  - [x] NotFoundPage 컴포넌트

#### 5) 상태 관리 초기 구현:
- [x] 간단한 상태 관리 시스템 설계
  - [x] 전역 상태 객체 생성 (예: 현재 로그인한 사용자 정보)
- [x] 상태 변경 함수 구현
  - [x] 상태 업데이트 시 관련 컴포넌트 리렌더링

#### 6) 이벤트 처리 및 DOM 조작:
- [x] 사용자 입력 처리 (로그인 폼, 프로필 수정 등)
- [x] 동적 컨텐츠 렌더링 (사용자 정보 표시, 페이지 전환 등)

#### 7) 라우팅 예외 처리:
- [x] 잘못된 라우트 접근 시 404 페이지 표시

### 심화과제

#### 1) 해시 라우터 구현
- [x] location.hash를 이용하여 SPA 라우터 구현
  - [x] '/#/' (홈 페이지)
  - [x] '/#/login' (로그인 페이지) 
  - [x] '/#/profile' (프로필 페이지)
 
#### 2) 라우트 가드 구현
- [x] 로그인 상태에 따른 접근 제어
- [x] 비로그인 사용자의 특정 페이지 접근 시 로그인 페이지로 리다이렉션

#### 3) 이벤트 위임

- [x] 이벤트 위임 방식으로 이벤트를 관리하고 있다.

## 과제 셀프회고

- 처음 설계 ([branch feat/function](https://github.com/Geunbaek/front_4th_chapter1-1/tree/feat/function))
```
# core

1. jsx 문법을 사용해서 컴포넌트를 생성한다.
2. 상태가 변경될 때마다 root 를 기준으로 새로운 element를 생성한다.
3. 생성된 element 와 현재 dom의 상태를 비교해가며 변경점만 적용한다.

- 문제 
1. 상태가 변경 될 때마다 너무 많은 리렌더링이 발생한다. 
2. 리렌더링 되었을 때 적절하게 상태를 초기화하지 못해서 페이지 전환시 상태가 그대로 남아있는 버그 발생 ( 해결 X )

- 해결
1. 현재 렌더링 상태를 두어서 렌더링이 진행중일 때에는 requestAnimationFrame 을 사용하여 렌더링을 대기하여 문제 해결

# store

1. observer pattern을 사용하여 구현
2. store의 상태가 변경될때마다 core의 상태를 변경시키는 함수를 구독하여 변경때마다 실행되도록 설계

# router

1. store를 활용해서 router의 상태를 관리하고 그 변경시마다 리렌더링 되도록 설계
```

- 현재

```
# core
1. jsx 문법을 사용한다.
2. web component 를 사용해서 컴포넌트를 렌더링 한다.

# store

1. observer pattern을 사용하여 구현
2. store의 상태가 변경될때마다 컴포넌트를 렌더링시키는 함수를 구독하여 변경때마다 실행되도록 설계

# router

1. 라우터가 변경될때마다 root 컴포넌트의 render 함수 호출
```

<!-- 과제에 대한 회고를 작성해주세요 -->

### 기술적 성장
<!-- 예시
- 새로 학습한 개념
- 기존 지식의 재발견/심화
- 구현 과정에서의 기술적 도전과 해결
-->

### 코드 품질
<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

- 코드 설계 관련 고민과 결정

1. 왜 jsx 를 사용했나?
- 처음 설계시 `createElement` 함수를 통해 element 를 생성하고 있는데 이를 코드로 작성하면 아래와 같다.
```javascript

// jsx 미적용시
const Component = () => {
  return createElement("header", null, createElement("div", null, "항해플러스"))
}

// jsx 적용시

<header class="bg-blue-600 text-white p-4 sticky top-0">
  <h1 class="text-2xl font-bold">항해플러스</h1>
</header>

```

적용 전 가독성이 너무 나쁘기에 jsx를 적용하는 선택을 하였습니다.

2. router의 middleware
- middleware 적용전 각 페이지마다 상태를 확인하고 그에 맞는 라우팅을 해줘야 했습니다.
그런데 수빈님의 코드의 authGuard 를 보고 저런식으로 처리를 하면 조금 더 선언형 프로그래밍에 가까워지고 해당 컴포넌트에서는 조건에 따른 라우팅을 신경써줄 필요가 없어서 더 명확하게 의도를 전달할 수 있어보여 적용하였습니다.


### 학습 효과 분석
<!-- 예시
- 가장 큰 배움이 있었던 부분
- 추가 학습이 필요한 영역
- 실무 적용 가능성
-->

- 추가 학습이 필요한 영역
1. 리액트의 상태관리 로직을 조금 더 학습하여 기존코드에 적용해봐야 할 것 같습니다.

- 아쉬웠던 점
1. 시간이 부족하여 기존 방식으로는 시간 내에 과제를 완료하지 못할 것 같아 web component를 사용하는 방식으로 변경하여 과제를 진행하였는데 과제가 목표로하는(?) 것과는 조금 동떨어진 방법으로 구현한 것 같아 많이 아쉽습니다.
